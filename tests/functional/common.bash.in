#!/bin/bash
#Based on runc tests/integration/helpers.bash

COR="${BATS_TEST_DIRNAME}/../../cc-oci-runtime"

# Test data dir.
TEST_DATA_DIR="$(readlink -e "${BATS_TEST_DIRNAME}")/data"
#Configuration files
CONFIG="${TEST_DATA_DIR}/config-minimal-cc-oci.json"
HYPERVISOR_ARGS="${BATS_TEST_DIRNAME}/../../data/hypervisor.args"

BUNDLE_DIR="@BUNDLE_TEST_PATH@"
ROOTFS_DIR="@BUNDLE_TEST_PATH@"
CONTAINERS_IMG="@CONTAINERS_IMG@"
CONTAINER_KERNEL="@CONTAINER_KERNEL@"
HYPERVISOR_PATH="@QEMU_PATH@"
COR_LOG_FILE="/run/opencontainer/containers/cc-oci-runtime.log"

# Verify components needed by Clear Containers
# If there is a missing component, the tests is skipped
function check_ccontainers() {

	out=$(@QEMU_PATH@ -machine help | grep -o pc-lite | tail -1)
	[ "$out" = "pc-lite" ] || skip "@QEMU_PATH@ does not have pc-lite support"

	if [ ! -d "$BUNDLE_DIR" ]
	then
		skip "bundle directory does not exits,\
 provide a valid bundle in $BUNDLE_DIR"
	elif [ ! -d "$ROOTFS_DIR" ]
	then
		skip "$ROOTFS_DIR directory does not exit,\
 provide a rootfs"
	elif [ ! -f "$CONTAINERS_IMG" ]
	then
		skip "Clear Container image $CONTAINERS_IMG  does\
 not exits, provide an image"
	elif [ ! -f "$CONTAINER_KERNEL" ]
	then
		skip "Clear Container kernel $CONTAINER_KERNEL does\
 not exits, provide a kernel"
	elif [ ! -x "$HYPERVISOR_PATH" ]
	then
		 skip "execute permission is not granted: $HYPERVISOR_PATH"
	fi

	for f in  $BUNDLE_DIR $ROOTFS_DIR $CONTAINERS_IMG $CONTAINER_KERNEL
	do
		[ -r "$f" ] || skip "cannot read file $f"
		[ -w "$f" ] || skip "write permission is not granted: $f"
	done

	#Copy hypervisor.args
	/bin/cp "$HYPERVISOR_ARGS" "${BUNDLE_DIR}/hypervisor.args"
	cd "$BATS_TEST_DIRNAME"
}

#Verifiy a container state
# @param <container-id>
# @param <status>  container status to check (e.g. running)
# @param <timeout> timeout to check container status
# return true if containter have the <status>, false if
#        the status is not the expected after timeout
function testcontainer() {
	container_id="$1"
	status="$2"
	timeout_cmd=${3:-5}
	i=0
	got=0
	cmd="$COR list --format table"
	[ "$timeout_cmd"  -eq "$timeout_cmd" ] || \
	{ log_msg "timeout is not a number"; exit 1; }
	while [ "$i" -lt "$timeout_cmd" ]
	do
		output=$(run_cmd "$cmd")
		[[ ${output} =~ ID\ +PID\ +STATUS\ +BUNDLE\ +CREATED+ ]]
		if [[ "${output}" == *"$container_id"*[0-9]*"$status"*"$BUNDLE_DIR"* ]]
		then
			got=1
			#Wait at least one second, for vm bootime
			#Cor spawns the hypervisor but it does not mean
			#That the vm is ready to work
			#Clear containres must boot in less than one second
			sleep 1
			break
		fi
		sleep 1
		i=$((i+1))
	done
	[ "$got" -eq 1 ] || { log_msg "FAILED"; exit 1; }
	log_msg "SUCCESS"
}

# Check if test is running as root, if not
# the test will be skipped
function check_root() {
	if [[ $(id -u) -ne 0 ]]
	then
		skip "Test requires root"
	fi
}

#Modify config.json's workload to execute a <cmd>
# @param <cmd>
# @param <options> ...
function workload_cmd() {
	#Copy new, no modified config.json
	/bin/cp "$CONFIG" "${BUNDLE_DIR}/config.json"
	cmd="\"$1\""
	shift
	for opt in "$@"
	do
	    cmd="$cmd\, \"$opt\""
	done
	sed -i "s,\"CMD\",$cmd,g" "$BUNDLE_DIR/config.json"
}

# Execute a command and vefiy its exit code
# if exit code is not the expected
# the current tests will fail
# @param cmd command to run
# @param expected_exit_code expected exit code
# @param timeout time to wait before kill command
function run_cmd(){
	cmd="$1"
	expected_exit_code="${2:-0}"
	timeout_cmd="$3"

	#Remove -e from bats enviroment
	set +e

	if [ "$timeout_cmd"  -eq "$timeout_cmd" ] 2> /dev/null
	then
		cmd="timeout $timeout_cmd $cmd"
	fi
	log_msg "Running: $cmd"
	eval "$cmd" 2>&1
	exit_code="$?"
	log_msg "exit code: $exit_code"
	log_msg "expected exit code: $expected_exit_code"

	if [ ! "$exit_code" -eq "$expected_exit_code" ]
	then
		if [ -f "$COR_LOG_FILE" ]
		then
			log_msg "See $TEST_LOG_FILE"
			cat "$COR_LOG_FILE" >> "$TEST_LOG_FILE"
		fi
	fi
	#Restore -e from bats enviroment
	set -e
	[ "$exit_code" -eq "$expected_exit_code" ]
}

function log_msg()
{
	msg="$*"
	echo "$msg" >&2
}

# Make temporal tests directory
function mktemp_tests_dir(){
       mktemp -d --tmpdir="$BATS_TMPDIR" --suffix=-cor-test
}

# Common setup for all the tests
function setup_common(){
	#Do all testing without root and with debug info
	COR_ROOT_DIR=$(mktemp_tests_dir)
	COR_GLOBAL_OPTIONS="--debug --root $COR_ROOT_DIR"
	COR_LOG_FILE="$COR_ROOT_DIR/cc-oci-runtime.log"
	COR="$COR $COR_GLOBAL_OPTIONS"
	TEST_LOG_FILE="$(pwd)/${BATS_TEST_NAME// /.}.log"
	if [ -f "$TEST_LOG_FILE" ]
	then
		rm "$TEST_LOG_FILE"
	fi
}

# Cleanup anything generated by this script
function cleanup_common(){
    if [ "$BATS_ERROR_STATUS" -eq 1 ]
    then
        # XXX: retain logs if tests fail
        echo "Test logs: $COR_ROOT_DIR" >&2
        return
    fi

    rm -rf "$COR_ROOT_DIR"
}
